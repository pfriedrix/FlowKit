import Foundation

/// Extension of `Store` that provides persistent storage capabilities for state management.
///
/// This extension adds functionality to persist the application's state to `UserDefaults`,
/// and restore it upon initialization. It is designed for use when the state conforms to
/// the `Codable` protocol, allowing it to be serialized and saved to local storage.
///
/// - Note: The state is encoded using `JSONEncoder` and stored as data in `UserDefaults`.
extension Store where State: Codable {
    
    /// A private computed property that returns a unique key for storing the state.
    ///
    /// The key is generated by combining the name of the `Reducer` type with `"-storage"`,
    /// ensuring a unique identifier for each store's state in `UserDefaults`.
    static private var storageKey: String {
        R.name + "-storage"
    }
    
    /// Persists the current state to `UserDefaults`.
    ///
    /// This method encodes the current state into a JSON format and saves it to
    /// `UserDefaults` under the storage key. If encoding fails, an error message is printed.
    ///
    /// - Parameter state: The state to be persisted.
    private func persist(_ state: State) {
        do {
            let encoded = try JSONEncoder().encode(state)
            UserDefaults.standard.set(encoded, forKey: Store.storageKey)
        } catch {
            print("Error: \(error)")
        }
    }
    
    /// Convenience initializer for `Store` that restores the state from storage if available.
    ///
    /// If a saved state is found in `UserDefaults`, it is restored and used as the initial
    /// state. Otherwise, the provided `defaultState` is used. This allows the store to
    /// automatically recover its state after an app restart or background session.
    ///
    /// - Parameters:
    ///   - reducer: The reducer that handles state updates and actions.
    ///   - defaultState: The default state to use if no saved state is found.
    public convenience init(reducer: R, defaultState: State) {
        let restoredState = Self.restore() ?? defaultState
        self.init(initial: restoredState, reducer: reducer)
    }
    
    /// Restores the saved state from `UserDefaults`.
    ///
    /// This method retrieves the saved state data from `UserDefaults`, decodes it
    /// using `JSONDecoder`, and returns the restored state. If decoding fails or no
    /// saved state is found, `nil` is returned.
    ///
    /// - Returns: The restored state, or `nil` if no saved state is available.
    public static func restore() -> State? {
        guard let saved = UserDefaults.standard.data(forKey: storageKey) else { return nil }
        
        do {
            let decoded = try JSONDecoder().decode(State.self, from: saved)
            return decoded
        } catch {
            print("Error: \(error)")
            return nil
        }
    }
    
    /// Dispatches an action to the store, triggering state updates.
    ///
    /// This method asynchronously dispatches an action to the reducer. It allows the store
    /// to process the action and apply any state changes that the reducer generates.
    /// The state updates are handled within the main actor context, ensuring that
    /// state changes are applied on the main thread.
    ///
    /// - Parameter action: The action to be dispatched to the reducer.
    public func dispatch(_ action: Action) {
        Task { @MainActor in
            await dispatch(state, action)
        }
    }
    
    /// Dispatches an action, updates the state, and persists the new state asynchronously.
    ///
    /// This private method processes an action through the reducer, updating the current state
    /// and persisting the result. If the effect returned by the reducer includes a subsequent action,
    /// this method recursively dispatches that action until no further actions remain. The state
    /// updates and persistence are handled in the main actor context to ensure thread safety.
    ///
    /// - Parameters:
    ///   - currentState: The current state before applying the action.
    ///   - action: The action to be processed by the reducer.
    @MainActor
    private func dispatch(_ currentState: State, _ action: Action) async {
        let effect = await reducer.reduce(into: currentState, action: action)
        persist(effect.state)
        
        DispatchQueue.main.async {
            self.state = effect.state
        }
        
        if let action = effect.action {
            await dispatch(effect.state, action)
        }
    }
}
